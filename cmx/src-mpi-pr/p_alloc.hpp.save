/* p_cmx header file */
#ifndef _P_CMX_H
#define _P_CMX_H

#include <mpi.h>

#include <stdlib.h>
#include <vector>

#include "group_impl.hpp"
#include "p_environment.hpp"
#include "cmx.hpp"

namespace CMX {

template <typename _data_type> class p_Allocation {
public:

/**
 * Constructor
 * @param bytes number of bytes being allocated on calling processor
 * @param group group of processors over which allocation is performed. If no
 * group is specified, assume allocation is on world group
 */
p_Allocation(int bytes, p_Group *group=NULL);
p_Allocation(int64_t bytes, p_Group *group=NULL);

/**
 * Destructor
 */
~p_Allocation();

/**
 * Access a list of pointers to data on remote processors
 * Note: this returns a standard vector, which may be slow. If needed,
 * access the internal vector of data using
 *   void **myptr = &ptrs[0];
 * @param ptrs a vector of pointers to data on all processors in the allocation
 * @return CMX_SUCCESS on success
 */
int access(std::vector<void*> &ptrs);

/**
 * Access internal group
 * @return pointer to group 
 */
p_Group* group();

/**
 * A collective communication and operations barrier on the internal group.
 * This is equivalent to calling group()->barrier()
 * @return CMX_SUCCESS on success
 */
int barrier();

/**
 * Contiguous Put.
 *
 * @param[in] src pointer to 1st segment at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int put(void *src, int dst_offset, int bytes, int proc);
int put(void *src, int64_t dst_offset, int64_t bytes, int proc);

/**
 * Strided Put.
 *
 * @param[in] src pointer to 1st segment at source
 * @param[in] src_stride array of strides at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] dst_stride array of strides at destination
 * @param[in] count number of units at each stride level count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int puts(void *src, int *src_stride, int dst_offset, int *dst_stride,
        int *count, int stride_levels, int proc);
int puts(void *src, int64_t *src_stride, int64_t dst_offset, int64_t *dst_stride,
        int64_t *count, int stride_levels, int proc);

/**
 * Vector Put.
 *
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int putv(cmx_giov_t *darr, int len, int proc);
int putv(cmx_giov_t *darr, int64_t len, int proc);

/**
 * Nonblocking Contiguous Put.
 *
 * @param[in] src pointer to 1st segment at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbput(void *src, int dst_offset, int bytes, int proc, cmx_request_t* req);
int nbput(void *src, int64_t dst_offset, int64_t bytes, int proc, cmx_request_t* req);

/**
 * Nonblocking Strided Put.
 *
 * @param[in] src pointer to 1st segment at source
 * @param[in] src_stride array of strides at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] dst_stride array of strides at destination
 * @param[in] count number of units at each stride level count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbputs(void *src, int *src_stride, int dst_offset, int *dst_stride,
        int *count, int stride_levels, int proc, cmx_request_t* req);
int nbputs(void *src, int64_t *src_stride, int64_t dst_offset, int64_t *dst_stride,
        int64_t *count, int stride_levels, int proc, cmx_request_t* req);

/**
 * Nonblocking Vector Put.
 *
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbputv(cmx_giov_t *darr, int len, int proc, cmx_request_t* req);
int nbputv(cmx_giov_t *darr, int64_t len, int proc, cmx_request_t* req);

/**
 * Contiguous Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] src pointer to 1st segment at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int acc(int op, void *scale, void *src, int dst_offset, int bytes, int proc);
int acc(int op, void *scale, void *src, int64_t dst_offset, int64_t bytes, int proc);

/**
 * Strided Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] src pointer to 1st segment at source
 * @param[in] src_stride [stride_levels] array of strides at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] dst_stride [stride_levels] array of strides at destination
 * @param[in] count [stride_levels+1] number of units at each stride level
 *            count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int accs(int op, void *scale, void *src, int *src_stride, int dst_offset,
    int *dst_stride, int *count, int stride_levels, int proc);
int accs(int op, void *scale, void *src, int64_t *src_stride, int64_t dst_offset,
    int64_t *dst_stride, int64_t *count, int stride_levels, int proc);

/**
 * Vector Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int accv(int op, void *scale, cmx_giov_t *darr, int len, int proc);
int accv(int op, void *scale, cmx_giov_t *darr, int64_t len, int proc);

/**
 * Nonblocking Contiguous Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] src pointer to 1st segment at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbacc(int op, void *scale, void *src, int dst_offset,
    int bytes, int proc, cmx_request_t *req);
int nbacc(int op, void *scale, void *src, int64_t dst_offset,
    int64_t bytes, int proc, cmx_request_t *req);

/**
 * Strided Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] src pointer to 1st segment at source
 * @param[in] src_stride array of strides at source
 * @param[in] dst_offset offset from start of data allocation on remote
 *            process
 * @param[in] dst_stride array of strides at destination
 * @param[in] count number of units at each stride level count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbaccs(int op, void *scale, void *src, int *src_stride,
    int dst_offset, int *dst_stride, int *count,
    int stride_levels, int proc, cmx_request_t *req);
int nbaccs(int op, void *scale, void *src, int64_t *src_stride,
    int64_t dst_offset, int64_t *dst_stride, int64_t *count,
    int stride_levels, int proc, cmx_request_t *req);

/**
 * Vector Atomic Accumulate.
 *
 * @param[in] op operation
 * @param[in] scale factor x += scale*y
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbaccv(int op, void *scale, cmx_giov_t *darr, int len, int proc, cmx_request_t *req);
int nbaccv(int op, void *scale, cmx_giov_t *darr, int64_t len, int proc, cmx_request_t *req);

/**
 * Contiguous Get.
 *
 * @param[in] dst pointer to 1st segment at destination
 * @param[in] src_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int get(void *dst, int src_offset, int bytes, int proc);
int get(void *dst, int64_t src_offset, int64_t bytes, int proc);

/**
 * Strided Get.
 *
 * @param[in] dst pointer to 1st segment at destination
 * @param[in] dst_stride array of strides at destination
 * @param[in] src_offset offset from start of data allocation on remote
 *            process
 * @param[in] src_stride array of strides at source
 * @param[in] count number of units at each stride level count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int gets(void *dst, int *dst_stride, int src_offset, int *src_stride,
    int *count, int stride_levels, int proc);
int gets(void *dst, int64_t *dst_stride, int64_t src_offset, int64_t *src_stride,
    int64_t *count, int stride_levels, int proc);

/**
 * Vector Get.
 *
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @return CMX_SUCCESS on success
 */
int getv(cmx_giov_t *darr, int len, int proc);
int getv(cmx_giov_t *darr, int64_t len, int proc);

/**
 * Nonblocking Contiguous Get.
 *
 * @param[in] dst pointer to 1st segment at destination
 * @param[in] src_offset offset from start of data allocation on remote
 *            process
 * @param[in] bytes number of bytes to transfer
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbget(void *dst, int src_offset, int bytes, int proc, cmx_request_t *req);
int nbget(void *dst, int64_t src_offset, int64_t bytes, int proc, cmx_request_t *req);

/**
 * Nonblocking Strided Get.
 *
 * @param[in] dst pointer to 1st segment at destination
 * @param[in] dst_stride array of strides at destination
 * @param[in] src_offset offset from start of data allocation on remote
 *            process
 * @param[in] src_stride array of strides at source
 * @param[in] count number of units at each stride level count[0]=bytes
 * @param[in] stride_levels number of stride levels
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbgets(void *dst, int *dst_stride, int src_offset, int *src_stride,
    int *count, int stride_levels, int proc, cmx_request_t *req);
int nbgets(void *dst, int64_t *dst_stride, int64_t src_offset, int64_t *src_stride,
    int64_t *count, int stride_levels, int proc, cmx_request_t *req);

/**
 * Nonblocking Vector Get.
 *
 * @param[in] darr descriptor array
 * @param[in] len length of descriptor array
 * @param[in] proc remote process(or) id. This processor must be in the same
 *            group as the allocation.
 * @param[out] req nonblocking request object
 * @return CMX_SUCCESS on success
 */
int nbgetv(cmx_giov_t *darr, int len, int proc, cmx_request_t *req);
int nbgetv(cmx_giov_t *darr, int64_t len, int proc, cmx_request_t *req);

/**
 * Flush all outgoing messages from me to the given proc on the group of the
 * allocation.
 * @param[in] proc the proc with which to flush outgoing messages
 * @return CMX_SUCCESS on success
 */
int fenceProc(int proc);

/**
 * Flush all outgoing messages to all procs in group of the allocation
 * @return CMX_SUCCESS on success
 */
int fenceAll();

/**
 * Read-modify-write atomic operation.
 *
 * The operations may be one of
 *  - CMX_SWAP
 *  - CMX_SWAP_LONG
 *  - CMX_FETCH_AND_ADD
 *  - CMX_FETCH_AND_ADD_LONG
 *
 * For the swap operations, the extra parameter is not used. The values of the
 * ploc and prem locations are swapped.
 *
 * For the fetch and add operations, the extra parameter is also used to
 * indicate how much to increment the remote value. The original remote value
 * is returned in the ploc parameter.
 *
 * @param[in] op the operation to perform (see list above)
 * @param[in] ploc the value to update locally
 * @param[in] rem_offset offset to remote value
 * @param[in] extra for CMX_FETCH_AND_ADD and CMX_FETCH_AND_ADD_LONG, the
 *            amount to increment the remote value by
 * @param[in] proc remote process(or) id
 * @param[in] cmx_hdl handle for data allocation
 * @return CMX_SUCCESS on success
 */
int readModifyWrite(int op, void *ploc, int rem_offset, int extra, int proc);
int readModifyWrite(int op, void *ploc, int64_t rem_offset, int extra, int proc);

/**
 * Waits for completion of non-blocking cmx operations with explicit handles.
 * @param[in] req the request handle
 * @return CMX_SUCCESS on success
 */
int wait(cmx_request_t *req);

/**
 * Checks completion status of non-blocking cmx operations with explicit
 * handles.
 * @param[in] req the request handle
 * @param[out] status true->completed, false->in progress
 * @return CMX_SUCCESS on success
 */
int test(cmx_request_t *req, bool *status);

/**
 * Wait for all outstanding implicit non-blocking operations to finish on the
 * group of the allocation
 * @return CMX_SUCCESS on success
 */
int waitAll();

/**
 * Wait for all outstanding implicit non-blocking operations to a particular
 * process to finish. Proc is in the group of the allocation
 * @param[in] proc proc for which all the outstanding non-blocking operations
 * have to be completed
 * @return CMX_SUCCESS on success
 */
int waitProc(int proc);

#if 0
/* This should probably be a separate class (if implemented at all) */
/**
 * Collectively create num locks locally.
 *
 * Remote procs may create a different number of locks, including zero.
 *
 * This function is always collective on the world group.
 *
 * @param[in] num number of locks to create locally
 * @return CMX_SUCCESS on success
 */
extern int cmx_create_mutexes(int num);

/**
 * Collectively destroy all previously created locks.
 *
 * This function is always collective on the world group.
 *
 * @param[in] num number of locks to create locally
 * @return CMX_SUCCESS on success
 */
extern int cmx_destroy_mutexes();

/**
 * Lock the given mutex on the given proc.
 *
 * This function is always on the world group.
 *
 * @param[in] mutex the ID of the mutex to lock on proc
 * @param[in] the ID of the proc which owns the mutex
 *
 * @return CMX_SUCCESS on success
 *         CMX_FAILURE if given mutex or proc is out of range
 */
extern int cmx_lock(int mutex, int proc);

/**
 * Unlock the given mutex on the given proc.
 *
 * This function is always on the world group.
 *
 * @param[in] mutex the ID of the mutex to unlock on proc
 * @param[in] the ID of the proc which owns the mutex
 *
 * @return CMX_SUCCESS on success
 *         CMX_FAILURE if given mutex or proc is out of range
 */
extern int cmx_unlock(int mutex, int proc);
#endif

private:

/* internal data structure for keeping track of allocation on
 * other processors */
typedef struct alloc_link {
  struct alloc_link *next;
  int rank;
  void *buf;
  int64_t size;
} cmx_alloc_t;

/* Pointer to environment object */
p_Environment *p_environment;

/* Group that allocation is on */
p_Group *p_group;

int p_rank;

/* size of allocation on this processor in bytes */
int64_t p_bytes;

/* pointer to local allocation on this processor */
void *p_buf;

/* linked list of allocation on other processors */
cmx_alloc_t *list;

/* pointer to global state */
cmx_group_world_t *p_state;

};
}

#endif /* _P_CMX_H */
